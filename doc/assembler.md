# C++ Assembler

The C++ assembler aims to be able to convert programs written for a variety of 70x assemblers in ASCII and archival formats into an intermediate representation which can them be converted to a variety of formats, such as ASCII listings and binary formats accepted by emulators.

The input for 70x assemblers was text on 80 column card using a Hollerith encoding or a BCD representation of the 80 column cards on tape or drum. The 704 could only access 72 columns of a card. A plugboard controller which 72 columns were used; columns 1-72 were used for assembler input, leaving the last 8 columns available for card identification and numbering, so that if a deck were dropped it could be put back in order with card sorting equipment. Listings generated by assemblers would print text in this area, but it would be generated by the assembler rather than coming from the actual cards since those last eight columns were not visible to the computer. Tape may have included all 80 characters, in which case listings from tape mught have the actual contents of columns 72-80.

The direct input to the assembler is a sequence of ASCII text, with each line (omitting the end of line) corresponding to one card. An ASCII space corresponds to no punch in a column. If the ASCII line is shorter than 72 characters, it is treated as though it were padded with spaces. If longer, the additional characters are ignored. The assemblers used a six bit BCD encoding for characters which is a simple transformation of the Hollerith encoding. Not all of the 64 available bit patterns were used for characters, and a few BCD character are not in ASCII (or even Unicode). Subtitutes are used for the BCD characters not in ASCII. The C++ assembler accepts ASCII that is not BCD provided that it is not used in a way that would need to be encoded as BCD. This is to support annotated input, such as modern commentary on the code that can be easily separated from the original code.

When assembling from archival formats, conversion of the archival input to ASCII lines can form the source for the assembler.

Punched cards are organized into fields with fixed widths at specific columns. The final field extends to the end of the card and is called the *variable* because it needs to be parsed into sub-fields of varying length, as controlled by the operation field. The position of the fixed fields varied from assembler to assembler.

The first step of the assembler is to convert the line of input into three fields, ``locationSymbol``, ``operation`` and ``variableAndComment`` (not true in the NY AP 1 assembler). The ``locationSymbol`` holds the label, if any, for the line, and the ``operation`` specifies how the line is to be treated. In particular, the ``operation`` determines how the ``variableAndComment`` are to be interpreted. The normal interpretation is that everything up to the first space is a comma-separated list of expressions and everything after the first space is a comment.

The location symbol tends to be a six-character field. This is because six six-bit BCD character fit in one 36-bit word, so two symbols can be compared with fixed-point comparisons. Since symbols are used in expressions and expressions cannot contain spaces (since a space marks the beginning of a comment) the location symbol is normalized by trimming out spaces.

As each line is processed, location symbols are given values, according to the semantics of the operation. Any expression use to assign a value to a location symbol should normally have already been assigned a values, but a pseudo-op allows symbols to be automatically assigned values if they have not already been seen. In later assemblers, two locations are used, one for the address where the instruction will be run from and one for the address where the loader should put it into memory.

After all lines have been processed, all referenced locations should have values. At this point, an assembled listing, memory image, or loadable binary can be produced, or the IR can serve as input for analysis tools.

# 70x Assemblers

When programming is described in [Principles of Operation Type 701](https://bitsavers.org/pdf/ibm/701/24-6042-1_701_PrincOps.pdf) it is described in terms of where to punch the holes in a binary loader card; four 18 bit instructions per row, starting from the bottom of the card going left to right. Although at assemblers were developed for the 701, [Nathaniel Rochester and William McClelland both developed assemblers](https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4640454)

## NY AP 1

In contrast, [704 electronic data-processing machine](https://bitsavers.org/pdf/ibm/704/24-6661-2_704_Manual_1955.pdf), briefly describes "Symbolic Programming", stating that more details can be found in the `NY AP 1` write-up. Not having access to a copy of the `NY AP 1` write-up, the short description must must serve as the source of information on the initial 704 assembler.

Symbols are used to name locations, and should only be used to name locations that are referred to elsewhere in the program. Symbols are six characters from any of the 47 BCD characters (includes space). A word holds six 6-bit characters, so symbols can be compared as integers. Locations are specified as a pair of a `Symbolic` and an `Absolute`, whose values are added. A `Class` can be `O` to indicate that the `Absolute` is octal and a class of `-` indicates a negative value.

The examples show a paper form with columns, only some of which are explained. The first two columns, not described, are `Identification` and `Card Class`. These are followed by `Location`, which is where a symbol defining an address is written. This is followed by `Operation code`, the three character operation. These are followed by either`Class`, `Number`, `Exponent`, and `Binary Place` or `Class`, `Address`, `Tag` and `Decrement`. `Address` and `Decrement` use three columns, `Class`, `Symbolic` and `Absolute`. The two values are added when both are specified. The `Tag` is ` `, `A`, `B` or `C` or `7` to indicate all tags. The final column is for comments.

There are at least two pseudo-ops, `OCT`, for specifying an octal constant for a word and `FXD` for a fixed-point constant. Constants are written 6 characters in each of the `Symbolic` and `Absolute` columns.

## UA SAP

Several source versions and documentation are available for the UA SAP assembler:
 - [sky-visions](https://sky-visions.com/ibm/704/)
 - [piercefuller](https://www.piercefuller.com/library/index.html)
Some media has been converted to ASCII, other is in pre-ASCII format and must be converted to ASCII.

An explanation of the part of the assembler [na-sap-12](https://github.com/diyessi/Z0ftware/blob/main/artifacts/src/na-sap12-1.sap) is in [Really Old Code](https://reallyoldcode.wordpress.com/).

## FAP

FAP is the FORTRAN Assembly Program, which extended UA SAP and could be used by FORTRAN programs.

# Operation of an assembler

# C++ Assembler

A modern C++ implementation of 70x assemblers will be migrated to this repo. It can currently generate UA SAP-style listings for UA SAP and is considerably faster than running UA SAP on SIMH. However, it does not yet support the creation of binary cards, tape or drum images.
